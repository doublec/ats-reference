ATS Reference
=============
Chris Double <chris.double@double.co.nz>
29 April 2012

Overloaded Functions
--------------------

The ATS prelude provides some functions that are overloaded with
implementations for different types. These can be used instead of the explicit
typed functions in many cases to make code easier to understand and more
generic.

print
~~~~~

Definition
^^^^^^^^^^
----
fun print (p):<!ref> void
----

Description
^^^^^^^^^^
Prints some representation of 'p' to standard output.

prerr
~~~~~

Definition
^^^^^^^^^^
----
fun prerr (p):<!ref> void
----

Description
^^^^^^^^^^^
Prints some representation of 'p' to standard error.

Math operators
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun - (a, b):<> c
fun + (a, b):<> c
----

Description
^^^^^^^^^^^
Standard mathematical operators overloaded for different types (pointers,
numbers, etc).

Comparison operators
~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun < (a, b):<> bool
fun <= (a, b):<> bool
fun > (a, b):<> bool
fun >= (a, b):<> bool
fun = (a, b):<> bool
fun <> (a, b):<> bool
fun != (a, b):<> bool
----

Description
^^^^^^^^^^^
Standard comparison operators overloaded for different types (pointers,
numbers, etc).

Pointer operators
~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun ~ {l:addr} (p: ptr l):<> bool (l > null)
----

Description
^^^^^^^^^^^
Overloaded for the pointer types to return 'true' if the pointer is not null.

succ
~~~~

Definition
^^^^^^^^^^
----
fun succ (a):<> b
----

Description
^^^^^^^^^^^
Returns the successor of a given value. For numbers and pointers this is the
value + 1.

pred
~~~~

Definition
^^^^^^^^^^
----
fun predc (a):<> b
----

Description
^^^^^^^^^^^
Returns the predecessor of a given value. For numbers and pointers this is the
value - 1.

padd
~~~~

Definition
^^^^^^^^^^
----
fun padd {l:addr} {i:int} (p, i) :<> p
----

Description
^^^^^^^^^^^
Adds 'i' to pointer 'p'.

psub
~~~~

Definition
^^^^^^^^^^
----
fun psub {l:addr} {i:int} (p, i) :<> p
----

Description
^^^^^^^^^^^
Subtracts 'i' from pointer 'p'.

compare
~~~~~~~

Definition
^^^^^^^^^^
----
fun compare (a, b):<> Sgn 
----

Description
^^^^^^^^^^^
Returns a negative number if 'a' is less than 'b', a positive number if 'a' is
greater than 'b' and zero if 'a' equals 'b'.

tostring
~~~~~~~~

Definition
^^^^^^^^^^
----
fun tostring (x):<> strptr1
----

Description
^^^^^^^^^^^
Returns a string representation of value 'x'.

Linear Lists
------------

list_vt is a polymorphic linear datatype for dealing with linked lists. 
list_vt.sats contains the definition for datatypes and funtions that operate on
linear lists. Use of these routines does not require the garbage collector.

The list_vt datatype has two constructors. list_vt_nil and list_vt_cons.
The former represents an empty list and the latter a pair of a viewtype and an
existing list.

Constructors
~~~~~~~~~~~~

----
dataviewtype list_vt (a:viewt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vte (a, n))
  | list_vt_nil (a, 0)
----

The list_vt type is indexed by the type of the item contained in the list and
an integer representing the length of the list. A slightly simpler typedef is
provided that represents a list of any length:

----
viewtypedef List_vt (a:viewt@ype) = [n:int | n >=0] list_vt (a, n)
----

list_vt_length_is_nonnegative
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
prfun list_vt_length_is_nonnegative
  {a:vt0p} {n:int} (xs: !list_vt (a, n)): [n>=0] void
----

Description
^^^^^^^^^^^
Proof function that asserts that the linear list has a non-negative length.


list_vt_sing
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
macdef list_vt_sing (x) =
  list_vt_cons (,(x), list_vt_nil ())
----

Description
^^^^^^^^^^^
Creates a 'list_vt' containing single element

Example
^^^^^^^
----
implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, ~list_vt_nil ()) = a
  val () = print_int (b)
}
----

list_vt_pair
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
macdef list_vt_pair (x1, x2) =
  list_vt_cons (,(x1), list_vt_cons (,(x2), list_vt_nil))
----

Description
^^^^^^^^^^^
Creates a 'list_vt' containing two elements

Example
^^^^^^^
----
implement main() = {
  val a = list_vt_pair ("a", "b")
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_is_nil
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{} list_vt_is_nil
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n==0)
----

Description
^^^^^^^^^^^
Returns 'true' if the given list is empty.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, c) = a
  val () = assertloc (list_vt_is_nil (c))
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_is_cons
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{} list_vt_is_cons
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n > 0)
----

Description
^^^^^^^^^^^
Returns 'true' if the given list is not empty.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val () = assertloc (list_vt_is_cons (a))
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_make_array
~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_make_array {n:int}
  (A: &(@[a][n]) >> @[a?!][n], n: size_t n):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Given a reference to an array, return a linear list of the items in that
array. 

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  var !arr = @[string] ("a", "b")
  val a = list_vt_make_array (!arr, 2)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_of_arraysize
~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_of_arraysize
  {n:int} (arrsz: arraysize (a, n)):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Given an arraysize, destructively convert it into a linear list.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_int (b)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_copy
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:t0p}
list_vt_copy {n:int} (xs: !list_vt (a, n)):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Copy an existing linear list. Note that the items held in the list must be
non-linear. The implementation of this template function requires
'prelude/DATS/list.dats' to be loaded.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"
staload _ = "prelude/DATS/list.dats"

implement main() = {
  val a = list_vt_sing 42
  val b = list_vt_copy (a)
  val+ ~list_vt_cons (c, ~list_vt_nil ()) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = b
  val () = print_int (c)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_free
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:t0p}
list_vt_free (xs: List_vt a):<> void
----

Description
^^^^^^^^^^^
Frees the linear list, destroying it. The items in the list must be
non-linear. See 'list_vt_free_fun' for freeing a linear list containing linear
resources.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val () = list_vt_free (a)
}
----

list_vt_free_fun
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_free_fun (
  xs: List_vt a, f: (&a >> a?) -<fun> void
) :<> void 
----

Description
^^^^^^^^^^^
Frees the linear list, taking a function that will free the items held by the
list.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

dataviewtype foo = foo

fn foo_free (f: &foo >> foo?):<> void =
  case+ f of
  | ~foo () => ()

implement main() = {
  val a = list_vt_cons (foo, list_vt_nil ())
  val () = list_vt_free_fun (a, foo_free)
}
----

list_vt_length
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_length {n:int} (xs: !list_vt (a, n)):<> int n
----

Description
^^^^^^^^^^^
Returns the length of the linear list.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val len = list_vt_length (a)
  val () = printf("Length: %d\n", @(len))
  val () = list_vt_free (a)
}
----

list_vt_make_elt
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:t0p}
list_vt_make_elt {n:nat} (x: a, n: int n):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Return a linear list composed of length 'n' containing 'n' copies of 'x'. The
element type must be non-linear.

Example
^^^^^^^
----
staload _ ="prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_make_elt (42, 5)
  val () = printf("List is length: %d\n", @(list_vt_length (a)))
  val () = list_vt_free (a)
}
----

list_vt_append
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_append {m,n:int}
  (xs: list_vt (a, m), ys: list_vt (a, n)):<> list_vt (a, m+n)
----

Description
^^^^^^^^^^^
Returns a linear list containing the elements from 'xs' followed by the
elements in 'ys'. Both 'xs' and 'ys' are destroyed.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val b = list_vt_of_arraysize<int> $arrsz(43, 44)
  val c = list_vt_append (a, b)
  val () = printf("Length of c = %d\n", @(list_vt_length (c)))
  val () = list_vt_free (c)
}
----

list_vt_split_at
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_split_at {n:int} {i:nat | i <= n}
  (xs: &list_vt (a, n) >> list_vt (a, n-i), i: int i):<> list_vt (a, i)
----

Description
^^^^^^^^^^^
Given a reference to a linear list, and in index into that list 'i', return a
list containing the first 'i' items and modifies the original list to have the
remaining items.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  val b = list_vt_split_at (a, 3)

  fun loop {n:nat} (lst: !list_vt (int, n)): void =
    case+ lst of
    | list_vt_nil () => (fold@ lst; print_newline ())
    | list_vt_cons (i, !rest) => (print_int (i);
                                  loop (!rest);
				  fold@ lst)

  val () = (print_string ("a:"); print_newline (); loop (a))
  val () = (print_string ("b:"); print_newline (); loop (b))

  val () = list_vt_free (a)
  val () = list_vt_free (b)
}
----

list_vt_reverse
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_reverse {n:int} (xs: list_vt (a, n)):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Given a linear list, reverses the order of elements and returns the resulting
list. The original list is destroyed.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  val b = list_vt_reverse (a)

  val () = loop (b) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (print_int (i);
	                                     loop (!rest);
					     fold@ lst)
	   }

  val () = list_vt_free (b)
}
----

list_vt_reverse_append
~~~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_reverse_append {m,n:int}
  (xs: list_vt (a, m), ys: list_vt (a, n)):<> list_vt (a, m+n)
----

Description
^^^^^^^^^^^
Reverses the list 'xs' then appends 'ys' to the resulting list and returns it.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  var b = list_vt_of_arraysize<int> $arrsz(45, 46, 47, 48)

  val c = list_vt_reverse_append (a, b)

  val () = loop (c) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (printf("%d ", @(i));
	                                     loop (!rest);
					     fold@ lst)
	   }

  val () = list_vt_free (c)
}
----

list_vt_concat
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_concat (xss: List_vt (List_vt (a))):<> List_vt (a)
----

Description
^^^^^^^^^^^
Concatenates a list of lists into a single list.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(1, 2, 3, 4)
  var b = list_vt_of_arraysize<int> $arrsz(5, 6, 7, 8)
  var c = list_vt_of_arraysize<int> $arrsz(9, 10)
  var d = list_vt_cons (a, list_vt_pair (b, c))

  val e = list_vt_concat (d)

  val () = loop (e) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (printf("%d ", @(i));
	                                     loop (!rest);
					     fold@ lst)
	   }

  val () = list_vt_free (e)
}
----

list_vt_tabulate
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_tabulate_funenv
  {v:view} {vt:viewtype} {n:nat} {f:eff}
  (pf: !v | f: (!v | natLt n, !vt) -<f> a, n: int n, env: !vt)
  :<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_fun {n:nat} {f:eff}
  (f: natLt n -<f> a, n: int n):<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_vclo {v:view} {n:nat} {f:eff}
  (pf: !v | f: &(!v | natLt n) -<clo,f> a, n: int n):<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_cloptr {n:nat} {f:eff}
  (f: !(natLt n) -<cloptr,f> a, n: int n):<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_vcloptr {v:view} {n:nat} {f:eff}
  (pf: !v | f: !(!v | natLt n) -<cloptr,f> a, n: int n):<f> list_vt (a, n)
----

Description
^^^^^^^^^^^
'list_vt_tabulate' is a family of functions that are used to generate a linear
list given a function. The function is called 'n' times, with 'n' given as an
argument. The result of the function is used as the element of the nth
position of the generated list.

There is a variant of 'list_vt_tabulate' for the different function types
available in ATS:

|=========================================================================
| list_vt_tabulate_funenv  | General purpose version for any function type
| list_vt_tabulate_fun     | C type functions (<fun>)
| list_vt_tabulate_vclo    | Stack allocated closures (<clo>)
| list_vt_tabulate_cloptr  | Linear closures (<cloptr>)
| list_vt_tabulate_vcloptr | Linear closures with a proof argument
|=========================================================================

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_tabulate_fun<int> (lam (n) =<> n * 2, 4)
  
  val () = loop (a) where {
             fun loop {n:nat} (lst: list_vt (int, n)): void =
               case+ lst of
               | ~list_vt_nil () => print_newline ()
               | ~list_vt_cons (i, rest) => (printf("%d ", @(i));
	                                     loop (rest))
	   }

}
----

list_vt_foreach
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_foreach_funenv
  {v:view} {vt:viewtype} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: !(!v | &a, !vt) -<f> void, env: !vt)
  :<f> void

fun{a:vt0p}
list_vt_foreach_fun {n:int} {f:eff}
  (xs: !list_vt (a, n), f: (&a) -<fun,f> void):<f> void

fun{a:vt0p}
list_vt_foreach_vclo {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: &(!v | &a) -<clo,f> void):<f> void

fun{a:t0p}
list_vt_foreach_cloptr {n:int} {f:eff}
  (xs: !list_vt (a, n), f: !(&a) -<cloptr,f> void):<f> void

fun{a:t0p}
list_vt_foreach_vcloptr {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: !(!v | &a) -<cloptr,f> void):<f> void
----

Description
^^^^^^^^^^^
'list_vt_foreach' is a family of functions that are used to iterate over a
list, calling a function for each element in the list. The function receives
a reference to the list element as an argument.

There is a variant of 'list_vt_foreach' for the different function types
available in ATS:

|========================================================================
| list_vt_foreach_funenv  | General purpose version for any function type
| list_vt_foreach_fun     | C type functions (<fun>)
| list_vt_foreach_vclo    | Stack allocated closures (<clo>)
| list_vt_foreach_cloptr  | Linear closures (<cloptr>)
| list_vt_foreach_vcloptr | Linear closures with a proof argument
|========================================================================

Note that the 'cloptr' and 'vcloptr' variants work on lists containing types,
not viewtypes like the other variants.

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_tabulate_fun<int> (lam (n) =<> n * 2, 4)
  val () = list_vt_foreach_fun<int> (a, lam (x) =<>
                                         $effmask_all (printf("%d ", @(x))))
  val () = list_vt_free (a)
}
----

list_vt_iforeach
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_iforeach_funenv
  {v:view} {vt:viewtype} {n:int} {f:eff} (
  pf: !v
| xs: !list_vt (a, n), f: (!v | natLt n, &a, !vt) -<fun,f> void, env: !vt
) :<f> void

fun{a:vt0p}
list_vt_iforeach_fun {n:int} {f:eff}
  (xs: !list_vt (a, n), f: (natLt n, &a) -<fun,f> void):<f> void

fun{a:vt0p}
list_vt_iforeach_vclo {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: &(!v | natLt n, &a) -<clo,f> void):<f> void

fun{a:t0p}
list_vt_iforeach_cloptr {n:int} {f:eff}
  (xs: !list_vt (a, n), f: !(natLt n, &a) -<cloptr,f> void):<f> void

fun{a:t0p}
list_vt_iforeach_vcloptr {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: !(!v | natLt n, &a) -<cloptr,f> void):<f> void
----

Description
^^^^^^^^^^^
'list_vt_iforeach' is a family of functions that are used to iterate over a
list, calling a function for each element in the list. The function receives
as arguments the index of the element in the list and a reference to the list
element.

There is a variant of 'list_vt_iforeach' for the different function types
available in ATS:

|=========================================================================
| list_vt_iforeach_funenv  | General purpose version for any function type
| list_vt_iforeach_fun     | C type functions (<fun>)
| list_vt_iforeach_vclo    | Stack allocated closures (<clo>)
| list_vt_iforeach_cloptr  | Linear closures (<cloptr>)
| list_vt_iforeach_vcloptr | Linear closures with a proof argument
|=========================================================================

Note that the 'cloptr' and 'vcloptr' variants work on lists containing types,
not viewtypes like the other variants.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_tabulate_fun<int> (lam (n) =<> n * 2, 4)
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
  val () = list_vt_free (a)
}
----

list_vt_mergesort
~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_mergesort {n:int}
  (xs: list_vt (a, n), cmp: &(&a, &a) -<clo> int):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Sorts the list using the merge sort algorithm. Requires a function to provide
an ordering for elements in the list. 

The comparison function should be stack allocated (has tag <clo>) and requires
its arguments to be references. This means you can't use the prelude 'compare'
function directly. It should return:

|==================================================================
| negative integer | first argument less than second argument 
| 0                | first argument equals second argument
| positive integer | first argument is greater than second argument
|==================================================================

Example
^^^^^^^
----
staload _ = "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz (10, 2, 6, 4, 8)
  val () = printf("Unsorted:\n", @())
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
					   
  val () = printf("Sorted:\n", @())
  var !p_cmp = @lam (a: &int, b: &int): int =<> compare (a, b)
  val b = list_vt_mergesort (a, !p_cmp)
  val () = list_vt_iforeach_fun<int> (b, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
  val () = list_vt_free (b)
----

list_vt_quicksort
~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_quicksort {n:int} (xs: !list_vt (a, n), cmp: (&a, &a) -<fun> int):<> void
----

Description
^^^^^^^^^^^
Sorts a list using the quicksort algorithm. Unlike 'list_vt_mergesort' this
modifies the original list rather than returning the result. 

The comparison function should be a standard C function (has tag <fun>) and requires
its arguments to be references. This means you can't use the prelude 'compare'
function directly. It should return:

|==================================================================
| negative integer | first argument less than second argument 
| 0                | first argument equals second argument
| positive integer | first argument is greater than second argument
|==================================================================

The current 'list_vt_quicksort' implementation copies the list into an array
and uses the standard C library 'qsort' function to sort it. It then copies
the data back into the list. Due to the implementation details the following
additional files must be loaded to use 'list_vt_qucksort':

* 'prelude/DATS/array.dats'
* 'libc/SATS/stdlib.sats'

Example
^^^^^^^
----
staload _ = "libc/SATS/stdlib.sats"
staload _ = "prelude/DATS/list_vt.dats"
staload _ = "prelude/DATS/array.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz (10, 2, 6, 4, 8)
  val () = printf("Unsorted:\n", @())
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
					   
  val () = printf("Sorted:\n", @())
  fn cmp (a: &int, b: &int):<> int = compare (a, b)
  val () = list_vt_quicksort (a, cmp)
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
  val () = list_vt_free (a)
}
----

Pointers
--------

The prelude file 'prelude/SATS/pointer.sats' provides functions for
manipulating pointers. This includes printing, comparison, pointer arithmetic
and getting/setting values stored at the pointer location.

ptr_is_gtez
~~~~~~~~~~~

Definition
^^^^^^^^^^
----
praxi ptr_is_gtez
  {l:addr} (p: ptr l):<> [l >= null] void
----

Description
^^^^^^^^^^^
Proof function asserting that a pointer cannot have a negative address.

ptr_is_null 
~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun ptr_is_null (p: ptr):<> bool
----

Description
^^^^^^^^^^^
Given a pointer, return 'true' if the pointer is NULL.

Example
^^^^^^^
----
implement main() = {
  val a = null
  val () = assertloc (ptr_is_null (a))
}
----

ptr_isnot_null 
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun ptr_isnot_null (p: ptr):<> bool
----

Description
^^^^^^^^^^^
Given a pointer, return 'true' if the pointer is not NULL.

Example
^^^^^^^
----
implement main() = {
  val a = null + 1
  val () = assertloc (ptr_isnot_null (a))
}
----

add_ptr
~~~~~~~

Definition
^^^^^^^^^^
----
fun add_ptr_int
  (p: ptr, i: int):<> ptr
overload + with add_ptr_int

fun add_ptr_size
  (p: ptr, sz: size_t):<> ptr
overload + with add_ptr_size
----

Description
^^^^^^^^^^^

'add_ptr' is a family of functions for performing pointer arithmetic on the
pointer address. The two variants, suffixed by 'int' and 'size', allow adding
an 'int' or a 'size_t' respectively. The standard '+' mathematical operator is
overloaded for these functions so pointer arithmetic can be done with normal
math operators.

Example
^^^^^^^
----
implement main() = {
  val a = null
  val () = print (a)
  val () = print_newline ()
  val b = a + 4
  val () = print (b)
  val () = print_newline ()
  val c = add_ptr_int (b, 4)
  val () = print (c)
  val () = print_newline ()
}
----

sub_ptr
~~~~~~~

Definition
^^^^^^^^^^
----
fun sub_ptr_int
  (p: ptr, i: int):<> ptr
overload - with sub_ptr_int

fun sub_ptr_size
  (p: ptr, sz: size_t):<> ptr
overload - with sub_ptr_size
----

Description
^^^^^^^^^^^
'sub_ptr' is a family of functions for performing pointer arithmetic on the
pointer address. The two variants, suffixed by 'int' and 'size', allow
subtracting an 'int' or a 'size_t' respectively. The standard '-' mathematical
operator is overloaded for these functions so pointer arithmetic can be done
with normal math operators.

Example
^^^^^^^
----
implement main() = {
  val a = null + 8
  val () = print (a)
  val () = print_newline ()
  val b = a - 4
  val () = print (b)
  val () = print_newline ()
  val c = sub_ptr_int (b, 4)
  val () = print (c)
  val () = print_newline ()
}
----

Pointer Comparison
~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun lt_ptr_ptr (p1: ptr, p2: ptr):<> bool
and lte_ptr_ptr (p1: ptr, p2: ptr):<> bool

overload < with lt_ptr_ptr
overload <= with lte_ptr_ptr

fun gt_ptr_ptr (p1: ptr, p2: ptr):<> bool
and gte_ptr_ptr (p1: ptr, p2: ptr):<> bool

overload > with gt_ptr_ptr
overload >= with gte_ptr_ptr

fun eq_ptr_ptr (p1: ptr, p2: ptr):<> bool
and neq_ptr_ptr (p1: ptr, p2: ptr):<> bool
overload = with eq_ptr_ptr
overload <> with neq_ptr_ptr
overload != with neq_ptr_ptr
----

Description
^^^^^^^^^^^

This family of functions is used to compare pointers for equality, greater
than, less than, not equal, etc. The comparison operators are overloaded to
work with the comparison functions.

ptr1_of_ptr 
~~~~~~~~~~~

Definition
^^^^^^^^^^
----
castfn ptr1_of_ptr (p: ptr):<> [l:addr] ptr l
----

Description
^^^^^^^^^^^

Cast a 'ptr' to a 'ptr l', which is a dependently typed pointer indexed by its
address.

Example
^^^^^^^
----
implement main() = {
  val a = null + 4
  val b = ptr1_of_ptr (a)
  val () = print (b)
}
----

null
~~~~

Definition
^^^^^^^^^^
----
val null : ptr null
----

Description
^^^^^^^^^^^

'null' is the definition of the NULL pointer. It is a dependently typed
pointer indexed by the 'null' address value.

Example
^^^^^^^
----
implement main() = {
  val a = null
  val () = print (a)
}
----

ptr1_is_null
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun ptr1_is_null {l:addr}
  (p: ptr l):<> bool (l==null)
----

Description
^^^^^^^^^^^
Given a dependently typed pointer indexed by the address value, return 'true' if the pointer is NULL.

Example
^^^^^^^
----
implement main() = {
  val a = null
  val () = assertloc (ptr1_is_null (a))
}
----

ptr1_isnot_null 
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun ptr1_isnot_null {l:addr}
  (p: ptr l):<> bool (l > null)
overload ~ with ptr1_isnot_null
----

Description
^^^^^^^^^^^
Given a dependently typed pointer indexed by the address value, return 'true'
if the pointer is not NULL.

Example
^^^^^^^
----
implement main() = {
  val a = null + 4
  val () = assertloc (ptr1_isnot_null (a))
}
----

psucc
~~~~~

Definition
^^^^^^^^^^
----
fun psucc {l:addr} (p: ptr l):<> ptr (l + 1)
overload succ with psucc
----

Description
^^^^^^^^^^^
Returns the successor of a pointer - the pointer value incremented by one.

Example
^^^^^^^
----
implement main() = {
  val a = null
  val b = psucc (a)
  val () = print (b)
}
----

ppred
~~~~~

Definition
^^^^^^^^^^
----
fun ppred {l:addr} (p: ptr l):<> ptr (l - 1)
overload pred with ppred
----

Description
^^^^^^^^^^^
Returns the predecessor of a pointer - the pointer value decremented by one.

Example
^^^^^^^
----
implement main() = {
  val a = null
  val b = psucc (a)
  val () = print (b)
  val () = print_newline ()
  val c = ppred (b)
  val () = print (c)
}
----
