ATS Reference
=============
Chris Double <chris.double@double.co.nz>
29 April 2012

Linear Lists
------------

list_vt is a polymorphic linear datatype for dealing with linked lists. 
list_vt.sats contains the definition for datatypes and funtions that operate on
linear lists. Use of these routines does not require the garbage collector.

The list_vt datatype has two constructors. list_vt_nil and list_vt_cons.
The former represents an empty lists and the latter a pair of a viewtype an an
existing list.

Definitions
~~~~~~~~~~~

----
dataviewtype list_vt (a:viewt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vte (a, n))
  | list_vt_nil (a, 0)
----

The list_vt type is indexed by the type of the item contained in the list and
an integer representing the length of the list. A slightly simpler typedef is
provided that represents a list of any length:

----
viewtypedef List_vt (a:viewt\@ype) = [n:int | n >=0] list_vt (a, n)
----

list_vt_length_is_nonnegative
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

----
prfun list_vt_length_is_nonnegative
  {a:vt0p} {n:int} (xs: !list_vt (a, n)): [n>=0] void
----

Proof function that asserts that the linear list has a non-negative length.


list_vt_sing
~~~~~~~~~~~~

----
macdef list_vt_sing (x) =
  list_vt_cons (,(x), list_vt_nil ())
----

Creates a 'list_vt' containing single element

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, ~list_vt_nil ()) = a
  val () = print_int (b)
}
----

list_vt_pair
~~~~~~~~~~~~

----
macdef list_vt_pair (x1, x2) =
  list_vt_cons (,(x1), list_vt_cons (,(x2), list_vt_nil))
----

Creates a 'list_vt' containing two elements

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_pair ("a", "b")
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_is_nil
~~~~~~~~~~~~~~

----
fun{} list_vt_is_nil
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n==0)
----

Returns 'true' if the given list is empty.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, c) = a
  val () = assertloc (list_vt_is_nil (c))
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_is_cons
~~~~~~~~~~~~~~~

----
fun{} list_vt_is_cons
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n > 0)
----

Returns 'true' if the given list is not empty.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val () = assertloc (list_vt_is_cons (a))
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_make_array
~~~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_make_array {n:int}
  (A: &(@[a][n]) >> @[a?!][n], n: size_t n):<> list_vt (a, n)
----

Given a reference to an array, return a linear list of the items in that
array. 

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var !arr = @[string] ("a", "b")
  val a = list_vt_make_array (!arr, 2)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_of_arraysize
~~~~~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_of_arraysize
  {n:int} (arrsz: arraysize (a, n)):<> list_vt (a, n)
----

Given an arraysize, destructively convert it into a linear list.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_int (b)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_copy
~~~~~~~~~~~~

----
fun{a:t0p}
list_vt_copy {n:int} (xs: !list_vt (a, n)):<> list_vt (a, n)
----

Copy an existing linear list. Note that the items held in the list must be
non-linear. The implementation of this template function requires
'prelude/DATS/list.dats' to be loaded.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"
staload "prelude/DATS/list.dats"

implement main() = {
  val a = list_vt_sing 42
  val b = list_vt_copy (a)
  val+ ~list_vt_cons (c, ~list_vt_nil ()) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = b
  val () = print_int (c)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_free
~~~~~~~~~~~~

----
fun{a:t0p}
list_vt_free (xs: List_vt a):<> void
----

Frees the linear list, destroying it. The items in the list must be
non-linear. See 'list_vt_free_fun' for freeing a linear list containing linear
resources.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val () = list_vt_free (a)
}
----

list_vt_free_fun
~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_free_fun (
  xs: List_vt a, f: (&a >> a?) -<fun> void
) :<> void 
----

Frees the linear list, taking a function that will free the items held by the
list.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

dataviewtype foo = foo

fn foo_free (f: &foo >> foo?):<> void =
  case+ f of
  | ~foo () => ()

implement main() = {
  val a = list_vt_cons (foo, list_vt_nil ())
  val () = list_vt_free_fun (a, foo_free)
}
----

list_vt_length
~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_length {n:int} (xs: !list_vt (a, n)):<> int n
----

Returns the length of the linear list.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val len = list_vt_length (a)
  val () = printf("Length: %d\n", @(len))
  val () = list_vt_free (a)
}
----

list_vt_make_elt
~~~~~~~~~~~~~~~~

----
fun{a:t0p}
list_vt_make_elt {n:nat} (x: a, n: int n):<> list_vt (a, n)
----

Return a linear list composed of length 'n' containing 'n' copies of 'x'. The
element type must be non-linear.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_make_elt (42, 5)
  val () = printf("List is length: %d\n", @(list_vt_length (a)))
  val () = list_vt_free (a)
}
----

list_vt_append
~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_append {m,n:int}
  (xs: list_vt (a, m), ys: list_vt (a, n)):<> list_vt (a, m+n)
----

Returns a linear list containing the elements from 'xs' followed by the
elements in 'ys'. Both 'xs' and 'ys' are destroyed.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val b = list_vt_of_arraysize<int> $arrsz(43, 44)
  val c = list_vt_append (a, b)
  val () = printf("Length of c = %d\n", @(list_vt_length (c)))
  val () = list_vt_free (c)
}
----

list_vt_split_at
~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_split_at {n:int} {i:nat | i <= n}
  (xs: &list_vt (a, n) >> list_vt (a, n-i), i: int i):<> list_vt (a, i)
----

Given a reference to a linear list, and in index into that list 'i', return a
list containing the first 'i' items and modifies the original list to have the
remaining items.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  val b = list_vt_split_at (a, 3)

  fun loop {n:nat} (lst: !list_vt (int, n)): void =
    case+ lst of
    | list_vt_nil () => (fold@ lst; print_newline ())
    | list_vt_cons (i, !rest) => (print_int (i); loop (!rest); fold@ lst)

  val () = (print_string ("a:"); print_newline (); loop (a))
  val () = (print_string ("b:"); print_newline (); loop (b))

  val () = list_vt_free (a)
  val () = list_vt_free (b)
}
----

list_vt_reverse
~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_reverse {n:int} (xs: list_vt (a, n)):<> list_vt (a, n)
----

Given a linear list, reverses the order of elements and returns the resulting
list. The original list is destroyed.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  val b = list_vt_reverse (a)

  val () = loop (b) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (print_int (i); loop (!rest); fold@ lst)
	   }

  val () = list_vt_free (b)
}
----
