ATS Reference
=============
Chris Double <chris.double@double.co.nz>
29 April 2012

Linear Lists
------------

list_vt is a polymorphic linear datatype for dealing with linked lists. 
list_vt.sats contains the definition for datatypes and funtions that operate on
linear lists. Use of these routines does not require the garbage collector.

The list_vt datatype has two constructors. list_vt_nil and list_vt_cons.
The former represents an empty list and the latter a pair of a viewtype and an
existing list.

Constructors
~~~~~~~~~~~~

----
dataviewtype list_vt (a:viewt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vte (a, n))
  | list_vt_nil (a, 0)
----

The list_vt type is indexed by the type of the item contained in the list and
an integer representing the length of the list. A slightly simpler typedef is
provided that represents a list of any length:

----
viewtypedef List_vt (a:viewt@ype) = [n:int | n >=0] list_vt (a, n)
----

list_vt_length_is_nonnegative
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
prfun list_vt_length_is_nonnegative
  {a:vt0p} {n:int} (xs: !list_vt (a, n)): [n>=0] void
----

Description
^^^^^^^^^^^
Proof function that asserts that the linear list has a non-negative length.


list_vt_sing
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
macdef list_vt_sing (x) =
  list_vt_cons (,(x), list_vt_nil ())
----

Description
^^^^^^^^^^^
Creates a 'list_vt' containing single element

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, ~list_vt_nil ()) = a
  val () = print_int (b)
}
----

list_vt_pair
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
macdef list_vt_pair (x1, x2) =
  list_vt_cons (,(x1), list_vt_cons (,(x2), list_vt_nil))
----

Description
^^^^^^^^^^^
Creates a 'list_vt' containing two elements

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_pair ("a", "b")
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_is_nil
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{} list_vt_is_nil
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n==0)
----

Description
^^^^^^^^^^^
Returns 'true' if the given list is empty.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, c) = a
  val () = assertloc (list_vt_is_nil (c))
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_is_cons
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{} list_vt_is_cons
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n > 0)
----

Description
^^^^^^^^^^^
Returns 'true' if the given list is not empty.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val () = assertloc (list_vt_is_cons (a))
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_make_array
~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_make_array {n:int}
  (A: &(@[a][n]) >> @[a?!][n], n: size_t n):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Given a reference to an array, return a linear list of the items in that
array. 

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var !arr = @[string] ("a", "b")
  val a = list_vt_make_array (!arr, 2)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_of_arraysize
~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_of_arraysize
  {n:int} (arrsz: arraysize (a, n)):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Given an arraysize, destructively convert it into a linear list.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_int (b)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_copy
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:t0p}
list_vt_copy {n:int} (xs: !list_vt (a, n)):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Copy an existing linear list. Note that the items held in the list must be
non-linear. The implementation of this template function requires
'prelude/DATS/list.dats' to be loaded.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"
staload "prelude/DATS/list.dats"

implement main() = {
  val a = list_vt_sing 42
  val b = list_vt_copy (a)
  val+ ~list_vt_cons (c, ~list_vt_nil ()) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = b
  val () = print_int (c)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_free
~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:t0p}
list_vt_free (xs: List_vt a):<> void
----

Description
^^^^^^^^^^^
Frees the linear list, destroying it. The items in the list must be
non-linear. See 'list_vt_free_fun' for freeing a linear list containing linear
resources.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val () = list_vt_free (a)
}
----

list_vt_free_fun
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_free_fun (
  xs: List_vt a, f: (&a >> a?) -<fun> void
) :<> void 
----

Description
^^^^^^^^^^^
Frees the linear list, taking a function that will free the items held by the
list.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

dataviewtype foo = foo

fn foo_free (f: &foo >> foo?):<> void =
  case+ f of
  | ~foo () => ()

implement main() = {
  val a = list_vt_cons (foo, list_vt_nil ())
  val () = list_vt_free_fun (a, foo_free)
}
----

list_vt_length
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_length {n:int} (xs: !list_vt (a, n)):<> int n
----

Description
^^^^^^^^^^^
Returns the length of the linear list.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val len = list_vt_length (a)
  val () = printf("Length: %d\n", @(len))
  val () = list_vt_free (a)
}
----

list_vt_make_elt
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:t0p}
list_vt_make_elt {n:nat} (x: a, n: int n):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Return a linear list composed of length 'n' containing 'n' copies of 'x'. The
element type must be non-linear.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_make_elt (42, 5)
  val () = printf("List is length: %d\n", @(list_vt_length (a)))
  val () = list_vt_free (a)
}
----

list_vt_append
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_append {m,n:int}
  (xs: list_vt (a, m), ys: list_vt (a, n)):<> list_vt (a, m+n)
----

Description
^^^^^^^^^^^
Returns a linear list containing the elements from 'xs' followed by the
elements in 'ys'. Both 'xs' and 'ys' are destroyed.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val b = list_vt_of_arraysize<int> $arrsz(43, 44)
  val c = list_vt_append (a, b)
  val () = printf("Length of c = %d\n", @(list_vt_length (c)))
  val () = list_vt_free (c)
}
----

list_vt_split_at
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_split_at {n:int} {i:nat | i <= n}
  (xs: &list_vt (a, n) >> list_vt (a, n-i), i: int i):<> list_vt (a, i)
----

Description
^^^^^^^^^^^
Given a reference to a linear list, and in index into that list 'i', return a
list containing the first 'i' items and modifies the original list to have the
remaining items.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  val b = list_vt_split_at (a, 3)

  fun loop {n:nat} (lst: !list_vt (int, n)): void =
    case+ lst of
    | list_vt_nil () => (fold@ lst; print_newline ())
    | list_vt_cons (i, !rest) => (print_int (i);
                                  loop (!rest);
				  fold@ lst)

  val () = (print_string ("a:"); print_newline (); loop (a))
  val () = (print_string ("b:"); print_newline (); loop (b))

  val () = list_vt_free (a)
  val () = list_vt_free (b)
}
----

list_vt_reverse
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_reverse {n:int} (xs: list_vt (a, n)):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Given a linear list, reverses the order of elements and returns the resulting
list. The original list is destroyed.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  val b = list_vt_reverse (a)

  val () = loop (b) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (print_int (i);
	                                     loop (!rest);
					     fold@ lst)
	   }

  val () = list_vt_free (b)
}
----

list_vt_reverse_append
~~~~~~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_reverse_append {m,n:int}
  (xs: list_vt (a, m), ys: list_vt (a, n)):<> list_vt (a, m+n)
----

Description
^^^^^^^^^^^
Reverses the list 'xs' then appends 'ys' to the resulting list and returns it.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(41, 42, 43, 44)
  var b = list_vt_of_arraysize<int> $arrsz(45, 46, 47, 48)

  val c = list_vt_reverse_append (a, b)

  val () = loop (c) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (printf("%d ", @(i));
	                                     loop (!rest);
					     fold@ lst)
	   }

  val () = list_vt_free (c)
}
----

list_vt_concat
~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_concat (xss: List_vt (List_vt (a))):<> List_vt (a)
----

Description
^^^^^^^^^^^
Concatenates a list of lists into a single list.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var a = list_vt_of_arraysize<int> $arrsz(1, 2, 3, 4)
  var b = list_vt_of_arraysize<int> $arrsz(5, 6, 7, 8)
  var c = list_vt_of_arraysize<int> $arrsz(9, 10)
  var d = list_vt_cons (a, list_vt_pair (b, c))

  val e = list_vt_concat (d)

  val () = loop (e) where {
             fun loop {n:nat} (lst: !list_vt (int, n)): void =
               case+ lst of
               | list_vt_nil () => (fold@ lst; print_newline ())
               | list_vt_cons (i, !rest) => (printf("%d ", @(i));
	                                     loop (!rest);
					     fold@ lst)
	   }

  val () = list_vt_free (e)
}
----

list_vt_tabulate
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_tabulate_funenv
  {v:view} {vt:viewtype} {n:nat} {f:eff}
  (pf: !v | f: (!v | natLt n, !vt) -<f> a, n: int n, env: !vt)
  :<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_fun {n:nat} {f:eff}
  (f: natLt n -<f> a, n: int n):<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_vclo {v:view} {n:nat} {f:eff}
  (pf: !v | f: &(!v | natLt n) -<clo,f> a, n: int n):<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_cloptr {n:nat} {f:eff}
  (f: !(natLt n) -<cloptr,f> a, n: int n):<f> list_vt (a, n)

fun{a:vt0p}
list_vt_tabulate_vcloptr {v:view} {n:nat} {f:eff}
  (pf: !v | f: !(!v | natLt n) -<cloptr,f> a, n: int n):<f> list_vt (a, n)
----

Description
^^^^^^^^^^^
'list_vt_tabulate' is a family of functions that are used to generate a linear
list given a function. The function is called 'n' times, with 'n' given as an
argument. The result of the function is used as the element of the nth
position of the generated list.

There is a variant of 'list_vt_tabulate' for the different function types
available in ATS:

|=========================================================================
| list_vt_tabulate_funenv  | General purpose version for any function type
| list_vt_tabulate_fun     | C type functions (<fun>)
| list_vt_tabulate_vclo    | Stack allocated closures (<clo>)
| list_vt_tabulate_cloptr  | Linear closures (<cloptr>)
| list_vt_tabulate_vcloptr | Linear closures with a proof argument
|=========================================================================

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_tabulate_fun<int> (lam (n) =<> n * 2, 4)
  
  val () = loop (a) where {
             fun loop {n:nat} (lst: list_vt (int, n)): void =
               case+ lst of
               | ~list_vt_nil () => print_newline ()
               | ~list_vt_cons (i, rest) => (printf("%d ", @(i));
	                                     loop (rest))
	   }

}
----

list_vt_foreach
~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_foreach_funenv
  {v:view} {vt:viewtype} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: !(!v | &a, !vt) -<f> void, env: !vt)
  :<f> void

fun{a:vt0p}
list_vt_foreach_fun {n:int} {f:eff}
  (xs: !list_vt (a, n), f: (&a) -<fun,f> void):<f> void

fun{a:vt0p}
list_vt_foreach_vclo {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: &(!v | &a) -<clo,f> void):<f> void

fun{a:t0p}
list_vt_foreach_cloptr {n:int} {f:eff}
  (xs: !list_vt (a, n), f: !(&a) -<cloptr,f> void):<f> void

fun{a:t0p}
list_vt_foreach_vcloptr {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: !(!v | &a) -<cloptr,f> void):<f> void
----

Description
^^^^^^^^^^^
'list_vt_foreach' is a family of functions that are used to iterate over a
list, calling a function for each element in the list. The function receives
a reference to the list element as an argument.

There is a variant of 'list_vt_foreach' for the different function types
available in ATS:

|========================================================================
| list_vt_foreach_funenv  | General purpose version for any function type
| list_vt_foreach_fun     | C type functions (<fun>)
| list_vt_foreach_vclo    | Stack allocated closures (<clo>)
| list_vt_foreach_cloptr  | Linear closures (<cloptr>)
| list_vt_foreach_vcloptr | Linear closures with a proof argument
|========================================================================

Note that the 'cloptr' and 'vcloptr' variants work on lists containing types,
not viewtypes like the other variants.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_tabulate_fun<int> (lam (n) =<> n * 2, 4)
  val () = list_vt_foreach_fun<int> (a, lam (x) =<>
                                         $effmask_all (printf("%d ", @(x))))
  val () = list_vt_free (a)
}
----

list_vt_iforeach
~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_iforeach_funenv
  {v:view} {vt:viewtype} {n:int} {f:eff} (
  pf: !v
| xs: !list_vt (a, n), f: (!v | natLt n, &a, !vt) -<fun,f> void, env: !vt
) :<f> void

fun{a:vt0p}
list_vt_iforeach_fun {n:int} {f:eff}
  (xs: !list_vt (a, n), f: (natLt n, &a) -<fun,f> void):<f> void

fun{a:vt0p}
list_vt_iforeach_vclo {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: &(!v | natLt n, &a) -<clo,f> void):<f> void

fun{a:t0p}
list_vt_iforeach_cloptr {n:int} {f:eff}
  (xs: !list_vt (a, n), f: !(natLt n, &a) -<cloptr,f> void):<f> void

fun{a:t0p}
list_vt_iforeach_vcloptr {v:view} {n:int} {f:eff}
  (pf: !v | xs: !list_vt (a, n), f: !(!v | natLt n, &a) -<cloptr,f> void):<f> void
----

Description
^^^^^^^^^^^
'list_vt_iforeach' is a family of functions that are used to iterate over a
list, calling a function for each element in the list. The function receives
as arguments the index of the element in the list and a reference to the list
element.

There is a variant of 'list_vt_iforeach' for the different function types
available in ATS:

|=========================================================================
| list_vt_iforeach_funenv  | General purpose version for any function type
| list_vt_iforeach_fun     | C type functions (<fun>)
| list_vt_iforeach_vclo    | Stack allocated closures (<clo>)
| list_vt_iforeach_cloptr  | Linear closures (<cloptr>)
| list_vt_iforeach_vcloptr | Linear closures with a proof argument
|=========================================================================

Note that the 'cloptr' and 'vcloptr' variants work on lists containing types,
not viewtypes like the other variants.

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_tabulate_fun<int> (lam (n) =<> n * 2, 4)
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
  val () = list_vt_free (a)
}
----

list_vt_mergesort
~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_mergesort {n:int}
  (xs: list_vt (a, n), cmp: &(&a, &a) -<clo> int):<> list_vt (a, n)
----

Description
^^^^^^^^^^^
Sorts the list using the merge sort algorithm. Requires a function to provide
an ordering for elements in the list. 

The comparison function should be stack allocated (has tag <clo>) and requires
its arguments to be references. This means you can't use the prelude 'compare'
function directly. It should return:

|==================================================================
| negative integer | first argument less than second argument 
| 0                | first argument equals second argument
| positive integer | first argument is greater than second argument
|==================================================================

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz (10, 2, 6, 4, 8)
  val () = printf("Unsorted:\n", @())
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
					   
  val () = printf("Sorted:\n", @())
  var !p_cmp = @lam (a: &int, b: &int): int =<> compare (a, b)
  val b = list_vt_mergesort (a, !p_cmp)
  val () = list_vt_iforeach_fun<int> (b, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
  val () = list_vt_free (b)
----

list_vt_quicksort
~~~~~~~~~~~~~~~~~

Definition
^^^^^^^^^^
----
fun{a:vt0p}
list_vt_quicksort {n:int} (xs: !list_vt (a, n), cmp: (&a, &a) -<fun> int):<> void
----

Description
^^^^^^^^^^^
Sorts a list using the quicksort algorithm. Unlike 'list_vt_mergesort' this
modifies the original list rather than returning the result. 

The comparison function should be a standard C function (has tag <fun>) and requires
its arguments to be references. This means you can't use the prelude 'compare'
function directly. It should return:

|==================================================================
| negative integer | first argument less than second argument 
| 0                | first argument equals second argument
| positive integer | first argument is greater than second argument
|==================================================================

The current 'list_vt_quicksort' implementation copies the list into an array
and uses the standard C library 'qsort' function to sort it. It then copies
the data back into the list. Due to the implementation details the following
additional files must be loaded to use 'list_vt_qucksort':

* 'prelude/DATS/array.dats'
* 'libc/SATS/stdlib.sats'

Example
^^^^^^^
----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"
staload "prelude/DATS/array.dats"
staload "libc/SATS/stdlib.sats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz (10, 2, 6, 4, 8)
  val () = printf("Unsorted:\n", @())
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
					   
  val () = printf("Sorted:\n", @())
  fn cmp (a: &int, b: &int):<> int = compare (a, b)
  val () = list_vt_quicksort (a, cmp)
  val () = list_vt_iforeach_fun<int> (a, lam (i, x) =<>
                                          $effmask_all
					   (printf("%d: %d\n", @(i, x))))
  val () = list_vt_free (a)
}
----
