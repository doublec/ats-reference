ATS Reference
=============
Chris Double <chris.double@double.co.nz>
29 April 2012

Linear Lists
------------

list_vt is a polymorphic linear datatype for dealing with linked lists. 
list_vt.sats contains the definition for datatypes and funtions that operate on
linear lists. Use of these routines does not require the garbage collector.

The list_vt datatype has two constructors. list_vt_nil and list_vt_cons.
The former represents an empty lists and the latter a pair of a viewtype an an
existing list.

Definitions
~~~~~~~~~~~

----
dataviewtype list_vt (a:viewt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vte (a, n))
  | list_vt_nil (a, 0)
----

The list_vt type is indexed by the type of the item contained in the list and
an integer representing the length of the list. A slightly simpler typedef is
provided that represents a list of any length:

----
viewtypedef List_vt (a:viewt\@ype) = [n:int | n >=0] list_vt (a, n)
----

list_vt_length_is_nonnegative
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

----
prfun list_vt_length_is_nonnegative
  {a:vt0p} {n:int} (xs: !list_vt (a, n)): [n>=0] void
----

Proof function that asserts that the linear list has a non-negative length.


list_vt_sing
~~~~~~~~~

----
macdef list_vt_sing (x) =
  list_vt_cons (,(x), list_vt_nil ())
----

Creates a 'list_vt' containing single element

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, ~list_vt_nil ()) = a
  val () = print_int (b)
}
----

list_vt_pair
~~~~~~~~~

----
macdef list_vt_pair (x1, x2) =
  list_vt_cons (,(x1), list_vt_cons (,(x2), list_vt_nil))
----

Creates a 'list_vt' containing two elements

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_pair ("a", "b")
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_is_nil
~~~~~~~~~~~~~~

----
fun{} list_vt_is_nil
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n==0)
----

Returns 'true' if the given list is empty.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val+ ~list_vt_cons (b, c) = a
  val () = assertloc (list_vt_is_nil (c))
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_is_cons
~~~~~~~~~~~~~~~

----
fun{} list_vt_is_cons
  {a:vt0p} {n:int} (xs: !list_vt (a, n)):<> bool (n > 0)
----

Returns 'true' if the given list is not empty.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_sing (42)
  val () = assertloc (list_vt_is_cons (a))
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_nil () = c
  val () = print_int (b)
}
----

list_vt_make_array
~~~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_make_array {n:int}
  (A: &(@[a][n]) >> @[a?!][n], n: size_t n):<> list_vt (a, n)
----

Given a reference to an array, return a linear list of the items in that
array. 

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  var !arr = @[string] ("a", "b")
  val a = list_vt_make_array (!arr, 2)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_string (b)
  val () = print_newline ()
  val () = print_string (d)
}
----

list_vt_of_arraysize
~~~~~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_of_arraysize
  {n:int} (arrsz: arraysize (a, n)):<> list_vt (a, n)
----

Given an arraysize, destructively convert it into a linear list.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val+ ~list_vt_cons (b, c) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = c
  val () = print_int (b)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_copy
~~~~~~~~~~~~

----
fun{a:t0p}
list_vt_copy {n:int} (xs: !list_vt (a, n)):<> list_vt (a, n)
----

Copy an existing linear list. Note that the items held in the list must be
non-linear. The implementation of this template function requires
'prelude/DATS/list.dats' to be loaded.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"
staload "prelude/DATS/list.dats"

implement main() = {
  val a = list_vt_sing 42
  val b = list_vt_copy (a)
  val+ ~list_vt_cons (c, ~list_vt_nil ()) = a
  val+ ~list_vt_cons (d, ~list_vt_nil ()) = b
  val () = print_int (c)
  val () = print_newline ()
  val () = print_int (d)
}
----

list_vt_free
~~~~~~~~~~~~

----
fun{a:t0p}
list_vt_free (xs: List_vt a):<> void
----

Frees the linear list, destroying it. The items in the list must be
non-linear. See 'list_vt_free_fun' for freeing a linear list containing linear
resources.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val () = list_vt_free (a)
}
----

list_vt_free_fun
~~~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_free_fun (
  xs: List_vt a, f: (&a >> a?) -<fun> void
) :<> void 
----

Frees the linear list, taking a function that will free the items held by the
list.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

dataviewtype foo = foo

fn foo_free (f: &foo >> foo?):<> void =
  case+ f of
  | ~foo () => ()

implement main() = {
  val a = list_vt_cons (foo, list_vt_nil ())
  val () = list_vt_free_fun (a, foo_free)
}
----

list_vt_length
~~~~~~~~~~~~~~

----
fun{a:vt0p}
list_vt_length {n:int} (xs: !list_vt (a, n)):<> int n
----

Returns the length of the linear list.

----
staload "prelude/SATS/list_vt.sats"
staload "prelude/DATS/list_vt.dats"

implement main() = {
  val a = list_vt_of_arraysize<int> $arrsz(41, 42)
  val len = list_vt_length (a)
  val () = printf("Length: %d\n", @(len))
  val () = list_vt_free (a)
}
----
